<!DOCTYPE html>
<html lang="en" >

<head>
  <meta charset="UTF-8">
  
  
  

  <title>JsTOTPAuthenticator</title>

    <link rel="canonical" href="https://codepen.io/vpelss/pen/EayojzL">
  <meta name="viewport" content="width=device-width, initial-scale=1">
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<link rel="manifest" href="./manifest.json"> 
  
  <link rel='stylesheet' href='https://cdn.simplecss.org/simple.css'>
  

  
  
  
</head>

<body>
  totp<div_header style="display:flex;">
  <center style="width:100%">
    <span id="menu_icon">
      <a onclick="openMenu()" class="button">&#x2261;</a>
    </span>
    <span id="x_icon" hidden>
      <a onclick="closeMenu()" class="button">X</a>
    </span>
    &nbsp;&nbsp;&nbsp;
    <span>
      JsTOTPAuthenticator
    </span>
    <hr>
  </center>
</div_header>

<br>&nbsp;

<div_main_page id="main_page_component">

  <label for="seed">Seed</label><input type="text" value="3132333435363738393031323334353637383930" id="seed" name="seed" placeholder="Seed in Base32" oninput="eachSecondwrapper();">

  <div>
    <span>Step Hexed: </span>
    <span id="step"></span>
  </div>
  <div>
    <span>Seed Hexed: </span>
    <span id="key"></span>
  </div>
  <div>
    <span>TOTP:</span>
    <span id="totp"></span>
  </div>
  <div>
    <span>Countdown: </span>
    <span id="countdown"></span>
  </div>
  <div id="error"></div>

  </div>

</div_main_page>

<div_menu_page id="menu_page_component" hidden>

  <form>
    <center>
      <div>
        <input type="button" value="Get Alias List" onclick="GetAliasList();">
      </div>

      <div>
        <input type="button" value="Save Alias List" onclick="if(confirm('This will change your list. Are you sure?')){SaveAliasList();}">
      </div>

      <div>
        <input type="button" value="Export Alias List to Clipboard" onclick="if(confirm('This will export all Alias, settings, and comments to clipboard. Are you sure?')){ ExportAll(); }">
      </div>

      <div>
        <textarea id="JSONSave" rows="3" cols="50" placeholder="Import/Export/Backup Alias List. Save the text generated in a safe location." title="You can import/export your current Alias list (which is saved in the local cookie). This is helful to move it to another computer or use it as a backup." class="u-full-width">
</textarea>
      </div>
    </center>
  </form>

  <center>
    <div>
      <a href="#" id="install" class="button">Install as PWA</a>
    </div>

    <div>
      Links below will open in your default browser.
    </div>

    <div>
      <a href="https://vpelss.github.io/Forever_Passwords//README.md" class="button u-full-width" target="_blank">Help/Read Me</a>
    </div>

    <div>
      <a href="https://github.com/vpelss/JsTOTPAuthenticator" target="_blank" class="button u-full-width">Github</a>
    </div>

    <div>
      <a href="https://github.com/vpelss/JsTOTPAuthenticator/blob/main/LICENSE" target="_blank" class="button">Licence</a>
    </div>

    <div>
      <a href="https://www.emogic.com/cgi/fp/backup.php" target="blank" class="button u-full-width">Doesn't work?</a>
    </div>

  </center>

</div_menu_page>
  <script src='https://cdnjs.cloudflare.com/ajax/libs/scrypt-js/3.0.1/scrypt.js'></script>
    <script id="rendered-js" >
// the key is decrypted when needed to verify an OTP value, and re-encrypted immediately to limit exposure in the RAM to a short period of time

// https://github.com/Sammy-T/avdu/blob/master/vault/decrypt.go

let localStorageName = "JsTOTPAuthenticator";
let GlobalAssociativeArray = {};
let allowedBase32Lengths = {"7":"7","16":"16","24":"24","32":"32"};

const TE = new TextEncoder();
let TD = new TextDecoder();

function openMenu() {
  document.getElementById("main_page_component").style.display = "none";
  document.getElementById("menu_page_component").style.display = "block";
  document.getElementById("menu_icon").style.display = "none";
  document.getElementById("x_icon").style.display = "inline";
}

function closeMenu() {
  document.getElementById("main_page_component").style.display = "block";
  document.getElementById("menu_page_component").style.display = "none";
  document.getElementById("menu_icon").style.display = "inline";
  document.getElementById("x_icon").style.display = "none";
}

function GetAliasList() {
  LocalStorageToVar();
  document.getElementById("JSONSave").value = JSON.stringify(
    GlobalAssociativeArray,
    null,
    "\t"
  );
}

function VarToLocalStorage() {
  let AliasListString = JSON.stringify(GlobalAssociativeArray);
  if (supports_html5_storage()) {
    localStorage[localStorageName] = AliasListString;
    //setCookie("AliasList", "", yesterday, "", "", ""); //erase cookie as we want to use local storage now.
  } else {
    //save to cookie
    setCookie("AliasList", AliasListString, localStorageName, "", "", "");
  }
}

function LocalStorageToVar() {
  if (supports_html5_storage()) {
    if (typeof localStorage[localStorageName] === "undefined") {
      return;
    } //nothing to restore
    GlobalAssociativeArray = JSON.parse(localStorage[localStorageName]);
  } else {
    let data = getCookie("AliasList") || "{}";
    GlobalAssociativeArray = JSON.parse(data);
  }
}

function SaveAliasList() {
  if (document.getElementById("JSONSave").value == "") {
    GlobalAssociativeArray = {};
  } else {
    GlobalAssociativeArray = JSON.parse(
      document.getElementById("JSONSave").value
    );
  }
  VarToLocalStorage();
  //BuildAliasSelect();
}

function supports_html5_storage() {
  try {
    return "localStorage" in window && window.localStorage !== null;
    //return false;
  } catch (e) {
    return false;
  }
}

function ExportAll() {
  LocalStorageToVar();
  copytoclipboard2(JSON.stringify(GlobalAssociativeArray));
  alert("All your Alias, settings, and comments are on the clipboard!");
}

function copytoclipboard2(text) {
  let textarea = document.createElement("TEXTAREA");
  document.body.appendChild(textarea);
  textarea.innerHTML = text;
  textarea.value = text;
  textarea.select();
  document.execCommand("copy", false, null);
  textarea.remove();
}

// for references see: https://github.com/vpelss/JsTOTPAuthenticator
async function hmac(
  keyHexString,
  stepHexString16Bytes,
  returnDigits,
  hashFunctionString
) {
  let totp;
  try {
    let blockSize = 64;
    let k, msg, tempUint8Array, hashed;

    //all our input key strings should only have hex characters [0 .. F]
    msg = Uint8Array.fromHex(stepHexString16Bytes);
    k = Uint8Array.fromHex(keyHexString); //only accepts hex string lengths of even values and convertys to bytes. byte = 2 x hex

    //hmac_sha https://en.wikipedia.org/wiki/HMAC

    // create our Uint8Array key to the blockSize sized
    if (k.length > blockSize) {
      tempUint8Array = new Uint8Array(blockSize); //set to block size
      hashed = await window.crypto.subtle.digest("SHA-1", k); // hash the message
      tempUint8Array.set(new Uint8Array(hashed));
      k = tempUint8Array;
    } // Keys longer than blockSize are shortened by hashing them
    // Keys shorter than blockSize are padded to blockSize by padding with zeros on the right
    if (k.length < blockSize) {
      tempUint8Array = new Uint8Array(blockSize); //set to block size
      tempUint8Array.set(k);
      k = tempUint8Array;
    }
    // k should now be blockSize

    // create ipad and opad https://datatracker.ietf.org/doc/html/rfc2104#section-2
    let okey = new Uint8Array(k);
    okey.forEach(function (myByte, myIndex, myArray) {
      myArray[myIndex] = myArray[myIndex] ^ 0x5c;
    }); //key xor 0x5c
    let ikey = new Uint8Array(k);
    ikey.forEach(function (myByte, myIndex, myArray) {
      myArray[myIndex] = myArray[myIndex] ^ 0x36;
    }); //key xor 0x36

    // now do hash(o_key_pad concatenate hash(i_key_pad concatenate msg))

    tempUint8Array = concatenateUint8arrays([ikey, msg]); // i_key_pad + msg
    hashed = await window.crypto.subtle.digest("SHA-1", tempUint8Array);
    tempUint8Array = new Uint8Array(hashed); // hash(i_key_pad concatenate msg)

    tempUint8Array = concatenateUint8arrays([okey, tempUint8Array]); //o_key_pad âˆ¥ hash(i_key_pad + msg)
    hashed = await window.crypto.subtle.digest("SHA-1", tempUint8Array);
    hashed = new Uint8Array(hashed); // hash(o_key_pad concatenate hash(i_key_pad concatenate msg))

    //https://datatracker.ietf.org/doc/html/rfc4226#section-5.3
    let offset = hashed[hashed.length - 1] & 0xf; //last 4 bits of hashed

    //take 4 bytes at offset (minus the first bit) and use bits to create a decimal #
    let myBinary =
      ((hashed[offset] & 0x7f) << 24) | // not signed
      (hashed[offset + 1] << 16) |
      (hashed[offset + 2] << 8) |
      hashed[offset + 3];

    //take deciamal output of myBinary and reduce to returnDigits decimal characters
    // opt is the same as taking dp/myBinary taking the decimal and multiplying with dp
    let dp = 10 ** returnDigits;
    let otp = myBinary % dp;

    totp = otp.toString();
    while (totp.length < returnDigits) {
      // make sure it is returnDigits long. pad to the left
      totp = "0" + totp;
    }
    document.getElementById("error").innerHTML = ""; //clear error on success
    document.getElementById("step").innerHTML = stepHexString16Bytes;
    document.getElementById("key").innerHTML = keyHexString;
    document.getElementById("totp").innerHTML = totp;
  } catch (error) {
    document.getElementById("error").innerHTML = document.getElementById("error").innerHTML + error;
    document.getElementById("totp").innerHTML = ""; 
  } 
}

function encodeBase32(data) {
  const BASE32_ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
    let binaryString = "";
    for (let i = 0; i < data.length; i++) {
        binaryString += data.charCodeAt(i).toString(2).padStart(8, '0');
    }
    let padding = binaryString.length % 5;
    if (padding !== 0) binaryString = binaryString.padEnd(binaryString.length + 5 - padding, '0');
    let encoded = "";
    for (let i = 0; i < binaryString.length; i += 5) {
        encoded += BASE32_ALPHABET[parseInt(binaryString.slice(i, i + 5), 2)];
    }
    while (encoded.length % 8 !== 0) encoded += '=';
    return encoded;
}

// https://medium.com/@at.kishor.k/demystifying-base32-an-in-depth-guide-to-this-encoding-standard-697b9426fc25
function decodeBase32toHex(data) {
  const BASE32_ALPHABET = "ABCDEFGHIJKLMNOPQRSTUVWXYZ234567";
  const HEX_ALPHABET = "0123456789ABCDEF";
  data = data.replace(/=/g, ""); //remove padding
  let binaryString = "";
  for (let i = 0; i < data.length; i++) {
    binaryString += BASE32_ALPHABET.indexOf(data[i])
      .toString(2)
      .padStart(5, "0");
  }
  //CHANGE to 4 for hex character output
  //let padding = binaryString.length % 8;
  let padding = binaryString.length % 4;
  if (padding !== 0) {
    binaryString = binaryString.slice(0, -padding);
  }
  let decoded = "";
  for (let i = 0; i < binaryString.length; i += 4) {
    let decimalEquivilant = parseInt(binaryString.slice(i, i + 4), 2);
    decoded += HEX_ALPHABET[decimalEquivilant];
    //decoded += parseInt(binaryString.slice(i, i + 4), 2).toString(16).toUpperCase();
  }
  return decoded;
}

// https://evanhahn.com/the-best-way-to-concatenate-uint8arrays/
function concatenateUint8arrays(uint8arrays) {
  // Determine the length of the result.
  const totalLength = uint8arrays.reduce(
    (total, uint8array) => total + uint8array.byteLength,
    0
  );
  // Allocate the result.
  const result = new Uint8Array(totalLength);
  // Copy each Uint8Array into the result.
  let offset = 0;
  uint8arrays.forEach((uint8array) => {
    result.set(uint8array, offset);
    offset += uint8array.byteLength;
  });
  return result;
}

function eachSecondwrapper() {
  eachSecond();
}

function HexStringtoString(hexString) {
  let myUint8Array = Uint8Array.fromHex(hexString);
  let myString = TD.decode(myUint8Array);
  return myString;
}

function stringToBytes(val) {
  const result = [];
  for (let i = 0; i < val.length; i++) {
    result.push(val.charCodeAt(i));
  }
  return result;
}

async function eachSecond() {
  let unixTime = Date.now() / 1000; //in seconds
  let stepNow = unixTime / 30;
  let stepInt = Math.floor(stepNow);
  let timeLeft = Math.floor(30 - 30 * (stepNow - stepInt));
  //step MUST be in string HEX
  let step = stepInt.toString(16);
  document.getElementById("countdown").innerHTML = timeLeft;
  do {
    step = "0" + step;
  } while (step.length < 16);
  // step needs to be 16 characters
  let seedBase32 = document.getElementById("seed").value;
  
  try{
  if(allowedBase32Lengths[seedBase32.length] != seedBase32.length){
    let  myLength , values="";
    for(myLength in allowedBase32Lengths) {
      values = values + myLength + " ";
    }
    throw("Seed lengths must be " + values);
  }
}
catch(error){ 
  document.getElementById("error").innerHTML = error + "<br>";
  document.getElementById("totp").innerHTML = ""; 
  return;
}
  
  //since base32 each character is 5 bits, we need 8 base32 characters to encode 5 byte characters
  //so padding IS REQUIRED if base32 is not a multiple of 40 bits
  seed = decodeBase32toHex(seedBase32.toUpperCase()); //base32Str to HexStr
  //let jj = encodeBase32(seed);

  //characters Aegis Authy Mine
  // cc yes yes yes
  // 3xC no yes no
  // 4xC yes(modified) yes no
  // 5xC yes yes yes
  // 6xC no yes no
  // 7xC yes(modified) yes yes
  
  // google 16, 24, 32 base32 char only. so 80, 120, 160 bits : 10, 15, 20 bytes
 
  let returnDigits = 6;
  let crypto = "sha1";

  try {
    hmac(seed, step, returnDigits, crypto);
  } catch (error) {
    document.getElementById("error").innerHTML = document.getElementById("error").innerHTML + error;
    document.getElementById("totp").innerHTML = ""; 
  }
}

// MAIN //

//first test
//step MUST be in string HEX
//toString(16).toUpperCase()
step = Math.floor(1111111109 / 30)
  .toString(16)
  .toUpperCase();
do {
  step = "0" + step;
} while (step.length < 16);

let seed;
seed = document.getElementById("seed").value;
let returnDigits = 8;
let crypto = "sha1";

hmac(seed, step, returnDigits, crypto);

document.getElementById("seed").value = "MYTESTQ";

let myInterval = setInterval(eachSecond, 1000);

LocalStorageToVar();

//unencrypt
  // https://github.com/beemdevelopment/Aegis/blob/master/app/src/main/java/com/beemdevelopment/aegis/crypto/bc/SCrypt.java
  //https://github.com/tonyg/js-scrypt
  //https://github.com/ricmoo/scrypt-js?utm_source=cdnjs&utm_medium=cdnjs_link&utm_campaign=cdnjs_library#readme
  //https://cdnjs.cloudflare.com/ajax/libs/scrypt-js/3.0.1/scrypt.js

    /* public static final byte CRYPTO_AEAD_KEY_SIZE = 32;
    public static final byte CRYPTO_AEAD_TAG_SIZE = 16;
    public static final byte CRYPTO_AEAD_NONCE_SIZE = 12;

    public static final int CRYPTO_SCRYPT_N = 1 << 15;
    public static final int CRYPTO_SCRYPT_r = 8;
    public static final int CRYPTO_SCRYPT_p = 1; */

  if (typeof GlobalAssociativeArray != "undefined") {
    let salt, n, r, p, nonce, tag;

    test = HexStringtoString("48656c6c6f20476f7068657221");
    //salt = HexStringtoString(GlobalAssociativeArray.header.slots[0].salt);
    //nonce = HexStringtoString(GlobalAssociativeArray.header.params.nonce);
//    tag = HexStringtoString(GlobalAssociativeArray.header.params.tag);    
    salt = stringToBytes(GlobalAssociativeArray.header.slots[0].salt);
    n = GlobalAssociativeArray.header.slots[0].n;
    r = GlobalAssociativeArray.header.slots[0].r;
    p = GlobalAssociativeArray.header.slots[0].p;
    nonce = GlobalAssociativeArray.header.params.nonce;
    nonce = nonce.normalize('NFKC');
    nonce = stringToBytes(nonce);
    tag = stringToBytes(GlobalAssociativeArray.header.params.tag);
    dkLen = 32; //????
    password = "aaa";
    password = password.normalize('NFKC');
    
    //pw2 = TE.encode(password);
    //pw = new Uint8Array(pw2);
    pw = stringToBytes(password);
    //g =  await scrypt.scrypt( pw2 , salt , n , r , p  , dkLen);
    scryptOutput = scrypt.syncScrypt(pw, salt, n, r, p, dkLen);
    gg = TD.decode(scryptOutput);
    // scrypt . syncScrypt ( password , salt , N , r , p , dkLen ) => Uint8Array

    // Create a key using the slot values and provided password

    // Attempt to decrypt the master key
    //masterKey, err = aesgcm.Open(nil, nonce, keyData, nil)

    h = 9;
  }
  </script>

  
</body>

</html>
