<!DOCTYPE html>
<html lang="en" >

<head>
  <meta charset="UTF-8">
  
  
  

  <title>totp</title>

    <link rel="canonical" href="https://codepen.io/vpelss/pen/EayojzL">
  
  
  
  

  
  
  
</head>

<body>
  <!-- https://datatracker.ietf.org/doc/html/rfc6238 -->

<a href="https://en.wikipedia.org/wiki/Time-based_one-time_password" target="_blank">https://en.wikipedia.org/wiki/Time-based_one-time_password</a>
<p></p>
<a href="https://datatracker.ietf.org/doc/html/rfc6238" target="_blank">TOTP: Time-Based One-Time Password Algorithm</a>
<p></p>
<a href="https://datatracker.ietf.org/doc/html/rfc2104" target="_blank">HMAC Hashed Message Authentication Code</a>
<p></p>
<a href="https://en.wikipedia.org/wiki/HMAC" target="_blank">HMAC pseudo Code</a>

<p></p>
<div id="v1"></div>
<div id="v2"></div>
<div id="v3"></div>
  
    <script id="rendered-js" >
const text = "a";

async function digestMessage(messageString) {
  const msgUint8 = new TextEncoder().encode(messageString); // encode as (utf-8) Uint8Array
  const hashBuffer = await window.crypto.subtle.digest("SHA-1", msgUint8); // hash the message
  return hashBuffer;
}

v2 = new Uint8Array(v1);
pw = v2.toBase64();
document.getElementById("v1").innerHTML = v1;
document.getElementById("v2").innerHTML = v2;
document.getElementById("v3").innerHTML = pw;

j = 9;

//HOTP(sharedSecret,Counter) = Truncate(HMAC-SHA-1(sharedSecret,Counter))

//Count = Math.floor( (Current Unix time - T0) / 30 );

//the key is decrypted when needed to verify an OTP value, and re-encrypted immediately to limit exposure in the RAM to a short period of time

//message will be Count based on unixtime

async function hmac(keyString, messageInt, hash, blockSize) {
  //internal variables
  //key:        Bytes    // Array of bytes : the secret key
  //message:    Bytes    // Array of bytes to be hashed : the unixtime count
  //hash:       Function // The hash function to use (e.g. SHA-1)
  //blockSize:  Integer  // The block size of the hash function (e.g. 64 bytes for SHA-1)

  let key, tempKey;
  const TE = new TextEncoder();
  const TD = new TextDecoder();

  let keyLength = new TextEncoder().encode(keyString).length; //used to know the Uint8Array key length
  let message = new Uint8Array(blockSize); //everything to blockSize
  message.set(TE.encode(messageInt.toString())); //convert and copy in messageInt

  // create our Uint8Array key to the blockSize sized
  // Keys longer than blockSize are shortened by hashing them
  if (keyLength > blockSize) {
    key = new Uint8Array(blockSize); //set to block size
    tempKey = await digestMessage(TE.encode(keyString));
    //tempKey will be 20 bytes long : op of sha1
    v2 = new Uint8Array(tempKey); //convert promise to Uint8Array
    key.set(v2); //copy tempKey into blockSize key
  }
  // Keys shorter than blockSize are padded to blockSize by padding with zeros on the right
  if (keyLength < blockSize) {
    key = new Uint8Array(blockSize);
    TE.encodeInto(keyString, key);
  }
  //key should be blockSize long here
  let okey = new Uint8Array(key);
  okey[0] = okey[0] ^ 0x5;
  okey[1] = okey[2] ^ 0xc; //key xor 0x5c
  let ikey = new Uint8Array(key);
  ikey[0] = ikey[0] ^ 0x3;
  ikey[1] = ikey[1] ^ 0x6; //key xor 0x36
  //o_key_pad ← block_sized_key xor [0x5c blockSize]   // Outer padded key
  //i_key_pad ← block_sized_key xor [0x36 blockSize]   // Inner padded key

  // i_key_pad ∥ message
  ikey.forEach(function (myByte, myIndex, myAarray) {
    myAarray[myIndex] = myAarray[myIndex] | message[myIndex];
  });
  tempKey = new Uint8Array(blockSize); //set to block size
  let hashed = await digestMessage(ikey); //hash(i_key_pad ∥ message)
  tempKey.set(new Uint8Array(hashed)); //copy to blockSize version

  //o_key_pad ∥ hash(i_key_pad ∥ message)
   okey.forEach(function (myByte, myIndex, myAarray) {
    myAarray[myIndex] = myAarray[myIndex] | tempKey[myIndex];
  });
  hashed = await digestMessage(okey); // hash(o_key_pad ∥ hash(i_key_pad ∥ message))
  
  

  v3 = key.toBase64();
  //v3 = TD.decode(key);

  document.getElementById("v1").innerHTML = keyString;
  document.getElementById("v2").innerHTML = key;
  document.getElementById("v3").innerHTML = v3;

  j = 9;
}

let myTime = Date.now() * 1000; //in seconds
let count = Math.floor(myTime / 30);
hmac("a", count, "sha1", 64);
  </script>

  
</body>

</html>
