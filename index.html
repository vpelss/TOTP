<!DOCTYPE html>
<html lang="en" >

<head>
  <meta charset="UTF-8">
  
  
  

  <title>totp</title>

    <link rel="canonical" href="https://codepen.io/vpelss/pen/EayojzL">
  
  
  
  

  
  
  
</head>

<body>
  <!-- https://datatracker.ietf.org/doc/html/rfc6238 -->

<a href="https://en.wikipedia.org/wiki/Time-based_one-time_password" target="_blank">https://en.wikipedia.org/wiki/Time-based_one-time_password</a>
<p></p>
<a href="https://datatracker.ietf.org/doc/html/rfc6238" target="_blank">TOTP: Time-Based One-Time Password Algorithm</a>
<p></p>
<a href="https://datatracker.ietf.org/doc/html/rfc2104" target="_blank">HMAC Hashed Message Authentication Code</a>
<p></p>
<a href="https://en.wikipedia.org/wiki/HMAC" target="_blank">HMAC pseudo Code</a>
<p></p>
<a href="https://datatracker.ietf.org/doc/html/rfc4226#section-5.3" target="_blank">Generating an HOTP Value</a>


<p></p>
<div id="v1"></div>
<div id="v2"></div>
<div id="v3"></div>
  
    <script id="rendered-js" >
const text = "a";

async function digestMessage(messageString) {
  const msgUint8 = new TextEncoder().encode(messageString); // encode as (utf-8) Uint8Array
  const hashBuffer = await window.crypto.subtle.digest("SHA-1", msgUint8); // hash the message
  return hashBuffer;
}

v2 = new Uint8Array(v1);
pw = v2.toBase64();
document.getElementById("v1").innerHTML = v1;
document.getElementById("v2").innerHTML = v2;
document.getElementById("v3").innerHTML = pw;

j = 9;

//HOTP(sharedSecret,Counter) = Truncate(HMAC-SHA-1(sharedSecret,Counter))

//Count = Math.floor( (Current Unix time - T0) / 30 );

//the key is decrypted when needed to verify an OTP value, and re-encrypted immediately to limit exposure in the RAM to a short period of time

//message will be Count based on unixtime

//rfc is atrocious. It assumes you know the inner workings of java crypto mac.
//it does all the ipad and outp[ad stuff]
async function hmac(keyString, stepsString16Bytes, returnDigits, hash) {
  //internal variables
  //key:        Bytes    // Array of bytes : the secret key
  //message:    Bytes    // Array of bytes to be hashed : the unixtime count
  //hash:       Function // The hash function to use (e.g. SHA-1)
  //blockSize:  Integer  // The block size of the hash function (e.g. 64 bytes for SHA-1)

  let blockSize = 64;
  let k, msg, tempKey;
  const TE = new TextEncoder();
  const TD = new TextDecoder();

  //all our keys should have hex characters
  msg = Uint8Array.fromHex(stepsString16Bytes);
  k = Uint8Array.fromHex(keyString);

  // GOOD TO HERE

  //hmac_sha inline

  // create our Uint8Array key to the blockSize sized
  // Keys longer than blockSize are shortened by hashing them
  if (k.length > blockSize) {
    tempKey = new Uint8Array(blockSize); //set to block size
    hash = await window.crypto.subtle.digest("SHA-1", k); // hash the message
    tempKey.set(new Uint8Array(hash));
    k = tempKey;
  }
  // Keys shorter than blockSize are padded to blockSize by padding with zeros on the right
  if (k.length < blockSize) {
    tempKey = new Uint8Array(blockSize); //set to block size
    tempKey.set(k);
    k = tempKey;
  }
  // k should now be blockSize

  let okey = new Uint8Array(k);
okey.forEach(function(myByte,myIndex,myArray){ //key xor 0x5c
  myArray[myIndex] =  myArray[myIndex] ^ 0x5c;
}
);
  let ikey = new Uint8Array(k);
  ikey.forEach(function(myByte,myIndex,myArray){ //key xor 0x5c
  myArray[myIndex] =  myArray[myIndex] ^ 0x36;
}
);
  //o_key_pad ← block_sized_key xor [0x5c blockSize]   // Outer padded key
  //i_key_pad ← block_sized_key xor [0x36 blockSize]   // Inner padded key
  
  
  
  tempKey = new Uint8Array(blockSize); //set to block size
  hashed = await digestMessage(ikey); //hash(i_key_pad ∥ message)
  tempKey.set(new Uint8Array(hashed)); //copy to blockSize version

  let message = new Uint8Array(blockSize); //everything to blockSize
  message.set(TE.encode(messageInt.toString())); //convert and copy in messageInt

  //key should be blockSize long here



  // i_key_pad ∥ message
  ikey.forEach(function (myByte, myIndex, myAarray) {
    myAarray[myIndex] = myAarray[myIndex] | message[myIndex];
  });
  tempKey = new Uint8Array(blockSize); //set to block size
  let hashed = await digestMessage(ikey); //hash(i_key_pad ∥ message)
  tempKey.set(new Uint8Array(hashed)); //copy to blockSize version

  //o_key_pad ∥ hash(i_key_pad ∥ message)
  okey.forEach(function (myByte, myIndex, myAarray) {
    myAarray[myIndex] = myAarray[myIndex] | tempKey[myIndex];
  });
  hashed = await digestMessage(okey); // hash(o_key_pad ∥ hash(i_key_pad ∥ message))

  v3 = key.toBase64();
  //v3 = TD.decode(key);

  document.getElementById("v1").innerHTML = keyString;
  document.getElementById("v2").innerHTML = key;
  document.getElementById("v3").innerHTML = v3;

  j = 9;
}

let unixTime = Date.now() * 1000; //in seconds
let steps = Math.floor(unixTime / 30).toString();
//needs to be 16 bytes
steps = 1;
do {
  steps = "0" + steps;
} while (steps.length < 16);
let seed = new TextEncoder().encode("12345678901234567890");
seed = "3132333435363738393031323334353637383930";
let returnDigits = 8;
let crypto = "sha1";

hmac(seed, steps, returnDigits, crypto);
  </script>

  
</body>

</html>
