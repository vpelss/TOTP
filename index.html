<!DOCTYPE html>
<html lang="en" >

<head>
  <meta charset="UTF-8">
  
  
  

  <title>totp</title>

    <link rel="canonical" href="https://codepen.io/vpelss/pen/EayojzL">
  
  
  
  

  
  
  
</head>

<body>
  <!-- https://datatracker.ietf.org/doc/html/rfc6238 -->

<a href="https://en.wikipedia.org/wiki/Time-based_one-time_password" target="_blank">https://en.wikipedia.org/wiki/Time-based_one-time_password</a>
<p></p>
<a href="https://datatracker.ietf.org/doc/html/rfc6238" target="_blank">TOTP: Time-Based One-Time Password Algorithm</a>
<p></p>
<a href="https://datatracker.ietf.org/doc/html/rfc2104" target="_blank">HMAC Hashed Message Authentication Code</a>
<p></p>
<a href="https://en.wikipedia.org/wiki/HMAC" target="_blank">HMAC pseudo Code</a>
<p></p>
<a href="https://datatracker.ietf.org/doc/html/rfc4226#section-5.3" target="_blank">Generating an HOTP Value</a>

<p></p>

<input type="text" placeholder="secret" value="3132333435363738393031323334353637383930" id="seed">

<p></p>
<div id="v1"></div>
<div id="v2"></div>
<div id="v3"></div>
  
    <script id="rendered-js" >
const text = "a";

async function digestMessage(messageString) {
  const msgUint8 = new TextEncoder().encode(messageString); // encode as (utf-8) Uint8Array
  const hashBuffer = await window.crypto.subtle.digest("SHA-1", msgUint8); // hash the message
  return hashBuffer;
}

//https://evanhahn.com/the-best-way-to-concatenate-uint8arrays/
function concatenateUint8arrays(uint8arrays) {
  // Determine the length of the result.
  const totalLength = uint8arrays.reduce(
    (total, uint8array) => total + uint8array.byteLength,
    0
  );
  // Allocate the result.
  const result = new Uint8Array(totalLength);
  // Copy each Uint8Array into the result.
  let offset = 0;
  uint8arrays.forEach((uint8array) => {
    result.set(uint8array, offset);
    offset += uint8array.byteLength;
  });
  return result;
}

//the key is decrypted when needed to verify an OTP value, and re-encrypted immediately to limit exposure in the RAM to a short period of time

//rfc is atrocious. It assumes you know the inner workings of java crypto/mac. So it effectively leaves out all the important code if you need to write it in a different language.
//crypto/mac does all the ipad and opad stuff
// https://en.wikipedia.org/wiki/HMAC was much more useful
async function hmac(keyString, stepsString16Bytes, returnDigits, hashFunction) {
  let blockSize = 64;
  let k, msg, tempUint8Array, hashed;
  const TE = new TextEncoder();
  const TD = new TextDecoder();

  //all our key strings should only have hex characters
  msg = Uint8Array.fromHex(stepsString16Bytes);
  k = Uint8Array.fromHex(keyString);

  //hmac_sha inline
  // create our Uint8Array key to the blockSize sized
  // Keys longer than blockSize are shortened by hashing them
  if (k.length > blockSize) {
    tempUint8Array = new Uint8Array(blockSize); //set to block size
    hashed = await window.crypto.subtle.digest("SHA-1", k); // hash the message
    tempUint8Array.set(new Uint8Array(hashed));
    k = tempUint8Array;
  }
  // Keys shorter than blockSize are padded to blockSize by padding with zeros on the right
  if (k.length < blockSize) {
    tempUint8Array = new Uint8Array(blockSize); //set to block size
    tempUint8Array.set(k);
    k = tempUint8Array;
  }
  // k should now be blockSize

  //o_key_pad ← block_sized_key xor [0x5c blockSize]   // Outer padded key
  //i_key_pad ← block_sized_key xor [0x36 blockSize]   // Inner padded key
  let okey = new Uint8Array(k);
  okey.forEach(function (myByte, myIndex, myArray) {
    myArray[myIndex] = myArray[myIndex] ^ 0x5c;
  }); //key xor 0x5c
  let ikey = new Uint8Array(k);
  ikey.forEach(function (myByte, myIndex, myArray) {
    myArray[myIndex] = myArray[myIndex] ^ 0x36;
  }); //key xor 0x36

  // hash(o_key_pad + hash(i_key_pad + msg))

  tempUint8Array = concatenateUint8arrays([ikey, msg]); // i_key_pad + msg
  hashed = await window.crypto.subtle.digest("SHA-1", tempUint8Array);
  tempUint8Array = new Uint8Array(hashed); // hash(i_key_pad + msg)

  tempUint8Array = concatenateUint8arrays([okey, tempUint8Array]); //o_key_pad ∥ hash(i_key_pad + msg)
  hashed = await window.crypto.subtle.digest("SHA-1", tempUint8Array);
  hashed = new Uint8Array(hashed); // hash(o_key_pad ∥ hash(i_key_pad ∥ message))

  // GOOD TO HERE

  //https://datatracker.ietf.org/doc/html/rfc4226#section-5.3
  let offset = hashed[hashed.length - 1] & 0xf; //last 4 bits of hashed
  let myBinary =
    ((hashed[offset] & 0x7f) << 24) |
    (hashed[offset + 1] << 16) |
    (hashed[offset + 2] << 8) |
    hashed[offset + 3];

  let dp = 10 ** returnDigits;
  // int otp = binary % DIGITS_POWER[codeDigits];
  let otp = myBinary % dp;

  result = Integer.toString(otp);
  while (result.length() < codeDigits) {
    result = "0" + result;
  }

  document.getElementById("v1").innerHTML = keyString;
  document.getElementById("v2").innerHTML = stepsString16Bytes;
  document.getElementById("v3").innerHTML = offset;

  j = 9;
}

let unixTime = Date.now() * 1000; //in seconds
let steps = Math.floor(unixTime / 30).toString();
//needs to be 16 bytes
steps = 1;
do {
  steps = "0" + steps;
} while (steps.length < 16);
let seed;
//= new TextEncoder().encode("12345678901234567890");
//seed = "3132333435363738393031323334353637383930";
seed = document.getElementById("seed").value;
let returnDigits = 8;
let crypto = "sha1";

hmac(seed, steps, returnDigits, crypto);
  </script>

  
</body>

</html>
