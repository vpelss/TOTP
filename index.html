<!DOCTYPE html>
<html lang="en" >

<head>
  <meta charset="UTF-8">
  
  
  

  <title>totp</title>

    <link rel="canonical" href="https://codepen.io/vpelss/pen/EayojzL">
  
  
  
  

  
  
  
</head>

<body>
  <!-- https://datatracker.ietf.org/doc/html/rfc6238 -->

<a href="https://en.wikipedia.org/wiki/Time-based_one-time_password" target="_blank">https://en.wikipedia.org/wiki/Time-based_one-time_password</a>
<p></p>
<a href="https://datatracker.ietf.org/doc/html/rfc6238" target="_blank">TOTP: Time-Based One-Time Password Algorithm</a>
<p></p>
<a href="https://datatracker.ietf.org/doc/html/rfc2104" target="_blank">HMAC Hashed Message Authentication Code</a>
<p></p>
<a href="https://en.wikipedia.org/wiki/HMAC" target="_blank">HMAC pseudo Code</a>
<p></p>
<a href="https://datatracker.ietf.org/doc/html/rfc4226#section-5.3" target="_blank">Generating an HOTP Value</a>


<p></p>
<div id="v1"></div>
<div id="v2"></div>
<div id="v3"></div>
  
    <script id="rendered-js" >
const text = "a";

async function digestMessage(messageString) {
  const msgUint8 = new TextEncoder().encode(messageString); // encode as (utf-8) Uint8Array
  const hashBuffer = await window.crypto.subtle.digest("SHA-1", msgUint8); // hash the message
  return hashBuffer;
}

v2 = new Uint8Array(v1);
pw = v2.toBase64();
document.getElementById("v1").innerHTML = v1;
document.getElementById("v2").innerHTML = v2;
document.getElementById("v3").innerHTML = pw;

j = 9;

//HOTP(sharedSecret,Counter) = Truncate(HMAC-SHA-1(sharedSecret,Counter))

//Count = Math.floor( (Current Unix time - T0) / 30 );

//the key is decrypted when needed to verify an OTP value, and re-encrypted immediately to limit exposure in the RAM to a short period of time

//message will be Count based on unixtime

//rfc is atrocious. It assumes you know the inner workings of java crypto mac.
//it does all the ipad and outp[ad stuff]
async function hmac(keyString, stepsString16Bytes, returnDigits, hash) {
  //internal variables
  //key:        Bytes    // Array of bytes : the secret key
  //message:    Bytes    // Array of bytes to be hashed : the unixtime count
  //hash:       Function // The hash function to use (e.g. SHA-1)
  //blockSize:  Integer  // The block size of the hash function (e.g. 64 bytes for SHA-1)

  let blockSize = 64;
  let k , msg , tempUint8Array , hashed;
  const TE = new TextEncoder();
  const TD = new TextDecoder();

  //all our keys should have hex characters
  //msg = new Uint8Array(blockSize); //set to block size
  //msg.set( Uint8Array.fromHex(stepsString16Bytes) );
  msg = Uint8Array.fromHex(stepsString16Bytes);
  k = Uint8Array.fromHex(keyString);

  //hmac_sha inline

  // create our Uint8Array key to the blockSize sized
  // Keys longer than blockSize are shortened by hashing them
  if (k.length > blockSize) {
    tempUint8Array = new Uint8Array(blockSize); //set to block size
    hashed = await window.crypto.subtle.digest("SHA-1", k); // hash the message
    tempUint8Array.set(new Uint8Array(hashed));
    k = tempUint8Array;
  }
  // Keys shorter than blockSize are padded to blockSize by padding with zeros on the right
  if (k.length < blockSize) {
    tempUint8Array = new Uint8Array(blockSize); //set to block size
    tempUint8Array.set(k);
    k = tempUint8Array;
  }
  // k should now be blockSize

  //o_key_pad ← block_sized_key xor [0x5c blockSize]   // Outer padded key
  //i_key_pad ← block_sized_key xor [0x36 blockSize]   // Inner padded key
  let okey = new Uint8Array(k);
  okey.forEach(function (myByte, myIndex, myArray) {
    myArray[myIndex] = myArray[myIndex] ^ 0x5c;
  }); //key xor 0x5c
  let ikey = new Uint8Array(k);
  ikey.forEach(function (myByte, myIndex, myArray) {
    myArray[myIndex] = myArray[myIndex] ^ 0x36;
  });     //key xor 0x36

  // GOOD TO HERE
  
  // hash(o_key_pad ∥ hash(i_key_pad ∥ message))
  
  // i_key_pad ∥ msg : msg will be shorter
  //ikey.forEach(function (myByte, myIndex, myAarray) {
  msg.forEach(function (myByte, myIndex, myAarray) {
    ikey[myIndex] = ikey[myIndex] | myAarray[myIndex];
  });
  
  hashed = await window.crypto.subtle.digest("SHA-1", ikey); // hash(i_key_pad ∥ message)
  tempUint8Array = new Uint8Array(hashed);
  
  //o_key_pad ∥ hash(i_key_pad ∥ message): tempUint8Array will be shoeter
  tempUint8Array.forEach(function (myByte, myIndex, myAarray) {
    okey[myIndex] = okey[myIndex] | myAarray[myIndex];
  });
  
  hashed = await digestMessage(okey); // hash(o_key_pad ∥ hash(i_key_pad ∥ message))
  tempUint8Array = new Uint8Array(hashed);
  
 

  v3 = key.toBase64();
  //v3 = TD.decode(key);

  document.getElementById("v1").innerHTML = keyString;
  document.getElementById("v2").innerHTML = key;
  document.getElementById("v3").innerHTML = v3;

  j = 9;
}

let unixTime = Date.now() * 1000; //in seconds
let steps = Math.floor(unixTime / 30).toString();
//needs to be 16 bytes
steps = 1;
do {
  steps = "0" + steps;
} while (steps.length < 16);
let seed = new TextEncoder().encode("12345678901234567890");
seed = "3132333435363738393031323334353637383930";
let returnDigits = 8;
let crypto = "sha1";

hmac(seed, steps, returnDigits, crypto);
  </script>

  
</body>

</html>
